/*******************************************************************************
 * This file is part of cVoronoi.
 * Copyright (c) 2020 Bert Vandenbroucke (bert.vandenbroucke@gmail.com)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 ******************************************************************************/

/**
 * @file voronoi2d.h
 *
 * @brief 2D Voronoi grid.
 *
 * @author Bert Vandenbroucke (bert.vandenbroucke@ugent.be)
 */

#ifndef CVORONOI_VORONOI2D_H
#define CVORONOI_VORONOI2D_H

#include <string.h>

/**
 * @brief Voronoi interface.
 *
 * An interface is a connection between two neighbouring Voronoi cells. It is
 * completely defined by the indices of the generators that generate the two
 * neighbouring cells, a surface area and a midpoint position.
 */
struct voronoi_pair {
  /*! Pointer to particle corresponding to the generator on the left of the
   * interface (always a particle within the local cell). */
  int left;

  /*! Pointer to particle corresponding to the generator on the right of the
   * interface (can be a local particle, but also a particle in a
   * neighbouring cell). */
  int right;

  struct cell *right_cell;

  /*! Surface area of the interface. */
  double surface_area;

  /*! Midpoint of the interface. */
  double midpoint[3];

#ifdef VORONOI_STORE_CONNECTIONS
  /*! First vertex of the interface. */
  double a[2];

  /*! Second vertex of the interface. */
  double b[2];
#endif
};

/**
 * @brief Voronoi cell.
 *
 * A cell stores geometrical information about a Voronoi cell: its volume and
 * the location of its centroid.
 */
struct voronoi_cell {
  /*! Cell volume. */
  double volume;

  /*! Cell centroid. */
  double centroid[2];

#ifdef VORONOI_STORE_GENERATORS
  /*! Position of the cell generator. */
  double generator[2];
#endif

#ifdef VORONOI_STORE_CELL_STATS
  /*! Number of faces of this cell. */
  int nface;
#endif
};

/**
 * @brief Voronoi grid.
 *
 * The grid stores a copy of the coordinates of the grid generators, the
 * coordinates of the grid vertices and the edge connections that make up the
 * grid. For every generator, it stores the number of vertices for the cell
 * generated by it, and the offset of the cell edges in the edge array.
 */
struct voronoi {

  /*! @brief Voronoi cells. */
  struct voronoi_cell *cells;

  /*! @brief Number of cells. */
  int number_of_cells;

  /*! @brief Voronoi cell pairs. We store these per (SWIFT) cell, i.e. pairs[0]
   *  contains all pairs that are completely contained within this cell, while
   *  pairs[1] corresponds to pairs crossing the boundary between this cell and
   *  the cell with coordinates that are lower in all coordinate directions (the
   *  cell to the left, front, bottom, sid=0), and so on. */
  struct voronoi_pair *pairs[2];

  /*! @brief Current number of pairs per cell index. */
  int pair_index[2];

  /*! @brief Allocated number of pairs per cell index. */
  int pair_size[2];
};

/* Forward declarations */
static inline void voronoi_add_pair(struct voronoi *v, int sid,
                                    struct cell *restrict c,
                                    int left_part_pointer,
                                    int right_part_pointer, double ax,
                                    double ay, double bx, double by);

/**
 * @brief Initialise the Voronoi grid based on the given Delaunay tessellation.
 *
 * This function allocates the memory for the Voronoi grid arrays and creates
 * the grid in linear time by
 *  1. Computing the grid vertices as the midpoints of the circumcircles of the
 *     Delaunay triangles.
 *  2. Looping over all vertices and for each vertex looping (in
 *     counterclockwise order) over all triangles that link to that vertex.
 *
 * During the second step, the geometrical properties (cell centroid, volume
 * and face midpoint, area) are computed as well.
 *
 * @param v Voronoi grid.
 * @param d Delaunay tessellation (read-only).
 */
static inline void voronoi_init(struct voronoi *restrict v,
                                const struct delaunay *restrict d) {

  delaunay_assert(d->vertex_end > 0);

  /* the number of cells equals the number of non-ghost and non-dummy vertices
     in the Delaunay tessellation */
  v->number_of_cells = d->vertex_end - d->vertex_start;
  /* allocate memory for the voronoi cells */
  v->cells = (struct voronoi_cell *)malloc(v->number_of_cells *
                                           sizeof(struct voronoi_cell));
  /* Allocate memory to store vertices (will be freed at end) */
  double *vertices =
      (double *)malloc(2 * (d->triangle_index - 3) * sizeof(double));

  /* loop over the triangles in the Delaunay tessellation and compute the
     midpoints of their circumcircles. These happen to be the vertices of the
     Voronoi grid (because they are the points of equal distance to 3
     generators, while the Voronoi edges are the lines of equal distance to 2
     generators) */
  for (int i = 0; i < d->triangle_index - 3; i++) {
    struct triangle *t = &d->triangles[i + 3];
    int v0 = t->vertices[0];
    int v1 = t->vertices[1];
    int v2 = t->vertices[2];

    /* if the triangle is not linked to a non-ghost, non-dummy vertex, it is not
     * a grid vertex and we can skip it. */
    if (v0 >= v->number_of_cells && v1 >= v->number_of_cells &&
        v2 >= v->number_of_cells) {
      continue;
    }

    /* Extract coordinates from the Delaunay vertices (generators)
     * FUTURE NOTE: In swift we should read this from the particles themselves!
     * */
    double v0x, v0y, v1x, v1y, v2x, v2y;
    if (v0 < d->vertex_end || v0 >= d->ghost_offset) {
      v0x = d->vertices[2 * v0];
      v0y = d->vertices[2 * v0 + 1];
    } else {
      /* This could mean that a neighbouring cell of this grids cell is empty!
       * Or that we did not add all the necessary ghost vertices to the delaunay
       * tesselation. */
      voronoi_error(
          "Vertex is part of triangle with Dummy vertex! This could mean that "
          "one of the neighbouring cells is empty.");
    }
    if (v1 < d->vertex_end || v1 >= d->ghost_offset) {
      v1x = d->vertices[2 * v1];
      v1y = d->vertices[2 * v1 + 1];
    } else {
      voronoi_error(
          "Vertex is part of triangle with Dummy vertex! This could mean that "
          "one of the neighbouring cells is empty.");
    }
    if (v2 < d->vertex_end || v2 >= d->ghost_offset) {
      v2x = d->vertices[2 * v2];
      v2y = d->vertices[2 * v2 + 1];
    } else {
      voronoi_error(
          "Vertex is part of triangle with Dummy vertex! This could mean that "
          "one of the neighbouring cells is empty.");
    }

    geometry2d_compute_circumcenter(v0x, v0y, v1x, v1y, v2x, v2y,
                                    &vertices[2 * i]);
  } /* loop over the Delaunay triangles and compute the circumcenters */

  /* Allocate memory for the voronoi pairs. */
  for (int i = 0; i < 2; ++i) {
    v->pairs[i] =
        (struct voronoi_pair *)malloc(10 * sizeof(struct voronoi_pair));
    v->pair_index[i] = 0;
    v->pair_size[i] = 10;
  }

  /* loop over all cell generators, and hence over all non-ghost, non-dummy
     Delaunay vertices */
  for (int i = 0; i < v->number_of_cells; i++) {

    struct voronoi_cell *this_cell = &v->cells[i];
    double cell_volume = 0.;
    double cell_centroid[2] = {0., 0.};
    double centroid[2];
    int nface = 1;

    /* get the generator position, we use it during centroid/volume
       calculations */
    voronoi_assert(i < d->vertex_end);
    double ax = d->vertices[2 * i];
    double ay = d->vertices[2 * i + 1];

#ifdef VORONOI_STORE_GENERATORS
    this_cell->generator[0] = ax;
    this_cell->generator[1] = ay;
#endif

    /* Get a triangle containing this generator and the index of the generator
       within that triangle */
    int del_vert_ix = i + d->vertex_start;
    int t0 = d->vertex_triangles[del_vert_ix];
    int del_vert_ix_in_t0 = d->vertex_triangle_index[del_vert_ix];
    /* The first vertex for this cell: the circumcircle midpoint of this
       triangle */
    int vor_vert_ix = t0 - 3;
    int first_vor_vert_ix = vor_vert_ix;

    /* store the current vertex coordinates for geometry calculations */
    double cx = vertices[2 * vor_vert_ix];
    double cy = vertices[2 * vor_vert_ix + 1];

    /* now use knowledge of the triangle orientation convention to obtain the
       next neighbouring triangle that has this generator as vertex, in the
       counterclockwise direction */
    int next_t_ix_in_cur_t = (del_vert_ix_in_t0 + 1) % 3;

    int first_ngb_del_vert_ix = d->triangles[t0].vertices[next_t_ix_in_cur_t];

    int t1 = d->triangles[t0].neighbours[next_t_ix_in_cur_t];
    int cur_t_ix_in_next_t =
        d->triangles[t0].index_in_neighbour[next_t_ix_in_cur_t];
    /* loop around the voronoi cell generator (delaunay vertex) until we arrive
     * back at the original triangle */
    while (t1 != t0) {
      ++nface;
      vor_vert_ix = t1 - 3;

      /* get the current vertex position for geometry calculations.
         Each calculation involves the current and the previous vertex.
         The face geometry is completely determined by these (the face is in
         this case simply the line segment between (bx,by) and (cx,cy).
         The cell geometry is calculated by accumulating the centroid and
         "volume" for the triangle (ax, ay) - (bx, by) - (cx, cy). */
      double bx = cx;
      double by = cy;
      cx = vertices[2 * vor_vert_ix];
      cy = vertices[2 * vor_vert_ix + 1];

      double V = geometry2d_compute_centroid_volume_triangle(ax, ay, bx, by, cx,
                                                             cy, centroid);
      cell_volume += V;
      cell_centroid[0] += V * centroid[0];
      cell_centroid[1] += V * centroid[1];

      /* Get the index of the next triangle in the neighbour-list of the current
       * triangle */
      next_t_ix_in_cur_t = (cur_t_ix_in_next_t + 2) % 3;

      /* the neighbour corresponding to the face is the same vertex that
         determines the next triangle */
      int ngb_del_vert_ix = d->triangles[t1].vertices[next_t_ix_in_cur_t];
      if (ngb_del_vert_ix < d->ghost_offset) {
        /* only store pairs once */
        if (ngb_del_vert_ix > del_vert_ix) {
          voronoi_add_pair(v, 0, NULL, del_vert_ix, ngb_del_vert_ix, bx, by, cx,
                           cy);
        }
      } else {
        /* no check on ngb_del_vert_ix > del_vert_ix required, since this is
         * always true (del_vert_ix < d->ngb_offset) */
        voronoi_add_pair(v, 1, NULL, del_vert_ix, -1, bx, by, cx, cy);
      }

      cur_t_ix_in_next_t =
          d->triangles[t1].index_in_neighbour[next_t_ix_in_cur_t];
      t1 = d->triangles[t1].neighbours[next_t_ix_in_cur_t];
    } /* loop around the voronoi cell generator */

    /* don't forget the last edge for the geometry! */
    double bx = cx;
    double by = cy;
    cx = vertices[2 * first_vor_vert_ix];
    cy = vertices[2 * first_vor_vert_ix + 1];

    double V = geometry2d_compute_centroid_volume_triangle(ax, ay, bx, by, cx,
                                                           cy, centroid);
    cell_volume += V;
    cell_centroid[0] += V * centroid[0];
    cell_centroid[1] += V * centroid[1];

    if (first_ngb_del_vert_ix < d->ghost_offset) {
      if (first_ngb_del_vert_ix > del_vert_ix) {
        /* only store pairs once */
        voronoi_add_pair(v, 0, NULL, del_vert_ix, first_ngb_del_vert_ix, bx, by,
                         cx, cy);
      }
    } else {
      /* no check on other_vertex > i required, since this is always true */
      voronoi_add_pair(v, 1, NULL, del_vert_ix, -1, bx, by, cx, cy);
    }

    /* now compute the actual centroid by dividing the volume-weighted
       accumulators by the cell volume */
    cell_centroid[0] /= cell_volume;
    cell_centroid[1] /= cell_volume;
    this_cell->volume = cell_volume;
    this_cell->centroid[0] = cell_centroid[0];
    this_cell->centroid[1] = cell_centroid[1];
#ifdef VORONOI_STORE_CELL_STATS
    this_cell->nface = nface;
#endif
  } /* loop over all cell generators */

  /* free allocated memory */
  free(vertices);
}

/**
 * @brief Free up all memory used by the Voronoi grid.
 *
 * @param v Voronoi grid.
 */
static inline void voronoi_destroy(struct voronoi *restrict v) {
  free(v->cells);
  for (int i = 0; i < 2; ++i) {
    free(v->pairs[i]);
  }
}

/**
 * @brief Add a two particle pair to the grid.
 *
 * The grid connectivity is stored per cell sid: sid=0 corresponds to particle
 * pairs encountered during a self task (both particles are within the local
 * cell), while sid=1-26 correspond to particle interactions for which the right
 * neighbour is part of one of the 26 neighbouring cells.
 *
 * For each pair, we compute and store all the quantities required to compute
 * fluxes between the Voronoi cells: the surface area and midpoint of the
 * interface.
 *
 * @param v Voronoi grid.
 * @param sid 0 for pairs entirely in this cell, 1 for pairs between this cell
 * and a neighbouring cell.
 * @param cell Pointer to the cell of the right particle (NULL if the right
 * particle lives in the same cell as the left particle). For SWIFT only.
 * @param left_part_pointer Index of left particle in cell (particle in the
 * cell linked to this grid). FUTURE NOTE: For SWIFT, replace this with direct
 * pointer to the left particle.
 * @param right_part_pointer Index of right particle in cell (particle in the
 * cell linked to this grid), or -1 for ghost vertices. FUTURE NOTE: For SWIFT,
 * replace this with direct pointer to the right particle.
 * @param ax,ay,bx,by Vertices of the interface.
 */
static inline void voronoi_add_pair(struct voronoi *v, int sid,
                                    struct cell *restrict c,
                                    int left_part_pointer,
                                    int right_part_pointer, double ax,
                                    double ay, double bx, double by) {

  if (v->pair_index[sid] == v->pair_size[sid]) {
    v->pair_size[sid] <<= 1;
    v->pairs[sid] = (struct voronoi_pair *)realloc(
        v->pairs[sid], v->pair_size[sid] * sizeof(struct voronoi_pair));
  }
  struct voronoi_pair *this_pair = &v->pairs[sid][v->pair_index[sid]];
  this_pair->right_cell = c;
  this_pair->left = left_part_pointer;
  this_pair->right = right_part_pointer;
  this_pair->surface_area = geometry2d_compute_midpoint_area_face(
      ax, ay, bx, by, this_pair->midpoint);
#ifdef VORONOI_STORE_CONNECTIONS
  this_pair->a[0] = ax;
  this_pair->a[1] = ay;
  this_pair->b[0] = bx;
  this_pair->b[1] = by;
#endif
  ++v->pair_index[sid];
}

/**
 * @brief Sanity checks on the grid.
 *
 * Right now, this only checks the total volume of the cells.
 */
static inline void voronoi_check_grid(const struct voronoi *restrict v) {
  double V = 0.;
  for (int i = 0; i < v->number_of_cells; ++i) {
    V += v->cells[i].volume;
  }

  printf("Total volume: %g\n", V);
}

/**
 * @brief Write the Voronoi grid information to the given file.
 *
 * The output depends on the configuration. The maximal output contains 3
 * different types of output lines:
 *  - "G\tgx\tgx: x and y position of a single grid generator (optional).
 *  - "C\tcx\tcy\tV\tnface": centroid position, volume and (optionally) number
 *    of faces for a single Voronoi cell.
 *  - "F\tax\tay\tbx\tby\tleft\tngb\tright\tA\tmx\tmy": edge positions
 *    (optional), left and right generator index (and ngb cell index), surface
 *    area and midpoint position for a single two-pair interface.
 *
 * @param v Voronoi grid.
 * @param file File to write to.
 */
static inline void voronoi_write_grid(const struct voronoi *restrict v,
                                      FILE *file) {

  /* first write the cells (and generators, if those are stored) */
  for (int i = 0; i < v->number_of_cells; ++i) {
    struct voronoi_cell *this_cell = &v->cells[i];
#ifdef VORONOI_STORE_GENERATORS
    fprintf(file, "G\t%g\t%g\n", this_cell->generator[0],
            this_cell->generator[1]);
#endif
    fprintf(file, "C\t%g\t%g\t%g", this_cell->centroid[0],
            this_cell->centroid[1], this_cell->volume);
#ifdef VORONOI_STORE_CELL_STATS
    fprintf(file, "\t%i", this_cell->nface);
#endif
    fprintf(file, "\n");
  }
  /* now write the pairs */
  for (int ngb = 0; ngb < 2; ++ngb) {
    for (int i = 0; i < v->pair_index[ngb]; ++i) {
      struct voronoi_pair *pair = &v->pairs[ngb][i];
      fprintf(file, "F\t");
#ifdef VORONOI_STORE_CONNECTIONS
      fprintf(file, "%g\t%g\t%g\t%g\t", pair->a[0], pair->a[1], pair->b[0],
              pair->b[1]);
#endif
      fprintf(file, "%i\t%g\t%g\t%g\n", ngb, pair->surface_area,
              pair->midpoint[0], pair->midpoint[1]);
    }
  }
}

/**
 * @brief Print the Voronoi grid to a file with the given name.
 *
 * @param v Voronoi grid (read-only).
 * @param file_name Name of the output file.
 */
static inline void voronoi_print_grid(const struct voronoi *restrict v,
                                      const char *file_name) {

  FILE *file = fopen(file_name, "w");

  voronoi_write_grid(v, file);

  fclose(file);
}

#endif /* CVORONOI_VORONOI2D_H */
